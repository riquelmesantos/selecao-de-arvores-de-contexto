sequencia_vet
setwd('C:/Users/rique/Desktop/PIPGES/Dissertacao/Códigos/Comparacao_Estimadores')
log_perda <- function(seq, probs) {
ll <- 0
tam_max <- max(nchar(rownames(probs)))
for (i in (tam_max+1):nchar(seq)) {
passado <- stri_sub(seq, from = i-tam_max, to = i-1)
contexto <- intersect(sufixos(passado), rownames(probs))
if (length(contexto) == 0) return('Não foi encontrado contexto para a sequência', passado)
contexto <- contexto[nchar(contexto) == max(nchar(contexto))]
prox_simbolo <- stri_sub(seq, from = i, to = i)
prob <- probs[contexto, prox_simbolo]
if(prob == 0) prob <- 1e-10
ll <- ll + log(prob)
}
return(-ll / (nchar(seq) - tam_max))
}
residuos_deviance <- function(seq, probs) {
require(stringi)
residuos <- c()
tam_max <- max(nchar(rownames(probs)))
for (i in (tam_max+1):nchar(seq)) {
passado <- stri_sub(seq, from = i - tam_max, to = i - 1)
contexto <- intersect(sufixos(passado), rownames(probs))
if (length(contexto) == 0) {
warning("Não foi encontrado contexto para a sequência: ", passado)
next
}
contexto <- contexto[nchar(contexto) == max(nchar(contexto))]
prox_simbolo <- stri_sub(seq, from = i, to = i)
prob_1 <- probs[contexto, "1"]
prob_1 <- min(max(prob_1, 1e-10), 1 - 1e-10)  # evitar log(0)
if (prox_simbolo == "1") {
r <- sign(1 - prob_1) * sqrt(-2 * log(prob_1))
} else if (prox_simbolo == "0") {
r <- sign(0 - prob_1) * sqrt(-2 * log(1 - prob_1))
} else {
stop("Símbolo inválido: deve ser '0' ou '1'")
}
residuos <- c(residuos, r)
}
return(residuos)
}
log_like <- function(cont, probs, alfabeto){
contextos <- rownames(probs)
ll = 0
for(w in contextos){
for(a in alfabeto){
if (is.na(probs[w, a]) || probs[w, a] == 0) next
ll <- ll + (cont[w, a] * log(probs[w, a]))
}
}
return(ll)
}
sequencia_binaria <- function(cadeia, bin) {
breaks <- seq(0, floor(max(cadeia)) + 1, by = bin)
categorias <- cut(cadeia[,1], breaks = breaks, right = TRUE, labels = FALSE, include.lowest = TRUE)
binario <- rep(0, length(breaks) - 1)
binario[unique(na.omit(categorias))] <- 1
return(binario)
}
block_bootstrap <- function(sequencia, block_length, n, B) {
sequencia <- strsplit(sequencia, '')[[1]]
n_blocks <- ceiling(n / block_length)
blocks <- matrix(0, nrow = n_blocks, ncol = block_length)
samples <- list()
for(i in 1:B){
for (j in 1:n_blocks) {
start <- sample(1:(length(sequencia) - block_length + 1), 1)
blocks[j, ] <- sequencia[start:(start + block_length - 1)]
}
samples[[i]] <- paste(as.vector(t(blocks)), collapse = '')
}
return(samples)
}
dados_neuronio <- read.table("Conjunto de dados/cell_30.dat")
sequencia_vet <- sequencia_binaria(dados_neuronio, 0.029)
sequencia <- paste0(sequencia_vet, collapse = '')
log(nchar(sequencia))
dados_neuronio <- read.table("Conjunto de dados/cell_30.dat")
sequencia_vet <- sequencia_binaria(dados_neuronio, 0.022)
sequencia <- paste0(sequencia_vet, collapse = '')
log(nchar(sequencia))
library(igraph)
library(stringi)
library(BCT)
setwd('C:/Users/rique/Desktop/PIPGES/Dissertacao/Códigos/Comparacao_Estimadores')
source("algoritmos/algoritmo_contexto.R")
dados_neuronio <- read.table("Conjunto de dados/cell_30.dat")
sequencia_vet <- sequencia_binaria(dados_neuronio, 0.029)
sequencia <- paste0(sequencia_vet, collapse = '')
log(nchar(sequencia))
for(i in 2:300){
print(i)
limiar <- c(1:300/10)[i]
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = limiar*log(length(sequencia_vet)))
chains[[i]] <- chain
metrics_ <- metrics(chain)
metrics_list[[i]] <- metrics_
}
library(mixvlmc)
metrics_list <- list()
chains <- list()
for(i in 2:300){
print(i)
limiar <- c(1:300/10)[i]
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = limiar*log(length(sequencia_vet)))
chains[[i]] <- chain
metrics_ <- metrics(chain)
metrics_list[[i]] <- metrics_
}
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = 10*log(length(sequencia_vet)))
chain
draw(chain)
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = 10*log(length(sequencia_vet)))
draw(chain)
chain$vals
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = 1*log(length(sequencia_vet)))
draw(chain)
chain$vals
chain$nb_ctx
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = 10*log(length(sequencia_vet)))
draw(chain)
chain$nb_ctx
for(i in 2:300){
print(i)
limiar <- c(1:300/10)[i]
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = limiar*log(length(sequencia_vet)))
chains[[i]] <- chain
metrics_ <- metrics(chain)
metrics_list[[i]] <- metrics_
if(chain$nb_ctx == 2) break
}
chain
setwd("C:/Users/rique/Desktop/PIPGES/Dissertacao/Códigos/Comparacao_Estimadores/analise_dados_reais")
estimacoes_contexto_limpa <- readRDS("C:/Users/rique/Desktop/PIPGES/Dissertacao/Códigos/Comparacao_Estimadores/estimacoes_contexto_limpa.rds")
View()
View(estimacoes_contexto_limpa )
chains[[5]]
chains[[6]]
chains[[10]]
contexts(chains[[10]])
length(contexts(chains[[10]]))
nchar(contexts(chains[[10]]))
length(contexts(chains[[10]]))
paste(contexts(chains[[10]]))
contexts(chains[[10]])[1]
contexts(chains[[10]])[1][Context ]
contexts(chains[[10]])[1][Context]
contexts(chains[[10]])[1]
contexts(chains[[10]])[1][1]
contexts(chains[[10]])[1][1][1]
contexts(chains[[10]])[[1]]
contexts(chains[[10]], sequence = T)
contexts(chains[[10]], metrics = T)
contexts(chains[[10]],sequence =T )
contexts(chains[[10]],sequence =T ) [[1]]
contexts(chains[[10]],sequence =T ) [[1]][1]
contexts(chains[[10]],sequence =T ) [[1]][2]
contexts(chains[[10]],sequence =T ) [[1]][2][1]
contexts(chains[[10]],sequence =T ) [[1]][2]
chain$loglikelihood <- sapply(chains, function(x) x$loglikelihood)
chain$loglikelihood
chain$keep_match
chain$f_by
chain$extended_ll
tune_vlmc(
sequencia_vet,
criterion = c("BIC", "AIC"),
initial = c("truncated", "specific", "extended"),
alpha_init = NULL,
cutoff_init = NULL,
min_size = 2L,
max_depth = 100L,
backend = getOption("mixvlmc.backend", "R"),
verbose = 0,
save = c("best", "initial", "all")
)
tuned <- tune_vlmc(
sequencia_vet,
max_depth = 13,
)
tuned <- tune_vlmc(
sequencia_vet,
max_depth = 13
)
metrics_aucs <- sapply(1:length(metrics_list), function(x)
metrics_list[[x]]$auc
)
metrics_list
metrics_aucs
metrics_list[[x]]$auc
metrics_list[[1]]$auc
metrics_list
metrics_list[[1]]
metrics_list[[2]]
metrics_list[[2]]$auc
metrics_aucs <- sapply(2:length(metrics_list), function(x)  metrics_list[[x]]$auc)
metrics_aucs
plot(metrics_aucs, type = "l", xlab = "Limiar", ylab = "AUC", main = "AUC vs Limiar")
which.max(metrics_aucs)
metrics_list[[2]]$fake_data
x=2
logLik(chains[[x]])
ll <- sapply(2:length(metrics_list), function(x)  logLik(chains[[x]]))
ll
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
which.max(ll)
which.max(metrics_aucs)
which.max(ll)
tune_vlmc(sequencia_vet, criterion = 'AIC', max_depth = 13)
tune_aic <- tune_vlmc(sequencia_vet, criterion = 'AIC', max_depth = 13)
metrics_list[[x]]$aic
x
chains[[x]]$nb_ctx
aics <- sapply(2:length(metrics_list), function(x)  -2*ll[x] + 2*chains[[x]]$nb_ctx)
aics
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
which.max(metrics_aucs)
which.max(aics)
which.min(aics)
aics
ll
chains[[68]]
metrics_list[[x]]$nb_params
aics <- sapply(2:length(metrics_list), function(x)  -2*ll[x] + 2*chains[[x]]$nb_ctx)
aics
chains[[68]]
chains[[x]]$nb_ctx
chains[[x]]$nb_ctx
chains[[8]]$nb_ctx
chains[[68]]$nb_ctx
x=68
-2*ll[x] + 2*chains[[x]]$nb_ctx
ll[x]
ll
ll <- sapply(1:length(metrics_list), function(x)  logLik(chains[[x]]))
for(i in 1:300){
print(i)
limiar <- c(2:300/10)[i+1]
chain <- mixvlmc::vlmc(sequencia_vet, max_depth = 13, cutoff = limiar*log(length(sequencia_vet)))
chains[[i]] <- chain
metrics_ <- metrics(chain)
metrics_list[[i]] <- metrics_
if(chain$nb_ctx == 2) break
}
metrics_aucs <- sapply(1:length(metrics_list), function(x)  metrics_list[[x]]$auc)
ll <- sapply(1:length(metrics_list), function(x)  logLik(chains[[x]]))
aics <- sapply(1:length(metrics_list), function(x)  -2*ll[x] + 2*chains[[x]]$nb_ctx)
aics
plot(metrics_aucs, type = "l", xlab = "Limiar", ylab = "AUC", main = "AUC vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
plot(metrics_aucs, type = "l", xlab = "Limiar", ylab = "AUC", main = "AUC vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
aics <- sapply(1:length(metrics_list), function(x)  -2*ll[x] + 2*chains[[x]]$nb_ctx)
bics <- sapply(1:length(metrics_list), function(x)  -2*ll[x] + log(length(sequencia_vet))*chains[[x]]$nb_ctx)
plot(metrics_aucs, type = "l", xlab = "Limiar", ylab = "AUC", main = "AUC vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
plot(bics, type = "l", xlab = "Limiar", ylab = "BIC", main = "BIC vs Limiar")
which.min(bics)
chains[[4]]
which.min
order(bics)
bics[order(bics)]
bics <- sapply(1:length(metrics_list), function(x)  -2*ll[x] + 10*log(length(sequencia_vet))*chains[[x]]$nb_ctx)
plot(bics, type = "l", xlab = "Limiar", ylab = "BIC", main = "BIC vs Limiar")
bics[order(bics)]
order(bics)
bics <- sapply(1:length(metrics_list), function(x)  -2*ll[x] + log(length(sequencia_vet))*chains[[x]]$nb_ctx)
plot(metrics_aucs, type = "l", xlab = "Limiar", ylab = "AUC", main = "AUC vs Limiar")
plot(ll, type = "l", xlab = "Limiar", ylab = "Log Likelihood", main = "Log Likelihood vs Limiar")
plot(aics, type = "l", xlab = "Limiar", ylab = "AIC", main = "AIC vs Limiar")
plot(bics, type = "l", xlab = "Limiar", ylab = "BIC", main = "BIC vs Limiar")
bics[order(bics)]
chains[[4]]
best_chain <- chains[[best_chain_index]]
tune_aic <- tune_vlmc(sequencia_vet, criterion = 'AIC', max_depth = 13)
order(bics)
chains[[4]]
contexts(chains[[4]])
residuos_deviance_sinal <- function(seq, probs) {
residuos <- c()
tam_max <- max(nchar(rownames(probs)))
for (i in (tam_max + 1):nchar(seq)) {
passado <- stri_sub(seq, from = i - tam_max, to = i - 1)
contexto <- intersect(sufixos(passado), rownames(probs))
if (length(contexto) == 0) {
warning("Nenhum contexto encontrado para: ", passado)
next
}
contexto <- contexto[nchar(contexto) == max(nchar(contexto))]
simbolo_obs <- stri_sub(seq, from = i, to = i)
p_hat <- probs[contexto, simbolo_obs]
p_hat <- min(max(p_hat, 1e-10), 1 - 1e-10)
x_t <- as.numeric(simbolo_obs)
r <- sign(x_t - p_hat) * sqrt(-2 * log(p_hat))
residuos <- c(residuos, r)
}
return(residuos)
}
